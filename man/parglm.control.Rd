% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parglm.R
\name{parglm.control}
\alias{parglm.control}
\title{Auxiliary for Controlling GLM Fitting in Parallel}
\usage{
parglm.control(epsilon = 1e-08, maxit = 25, trace = FALSE,
  nthreads = 1L, block_size = NULL)
}
\arguments{
\item{epsilon}{positive convergence tolerance \eqn{\epsilon}.}

\item{maxit}{integer giving the maximal number of IWLS iterations.}

\item{trace}{logical indicating if output should be produced doing estimation.}

\item{nthreads}{number of cores to use. You may get the best performance by
using your number of physical cores if you data set is sufficiently large.}

\item{block_size}{number of observation to include in each parallel block.}
}
\value{
A list with components named as the arguments.
}
\description{
Auxiliary function for \code{\link{parglm}} fitting.
}
\examples{
# use one core
clotting <- data.frame(
 u = c(5,10,15,20,30,40,60,80,100),
 lot1 = c(118,58,42,35,27,25,21,19,18),
 lot2 = c(69,35,26,21,18,16,13,12,12))
f1 <- parglm(lot1 ~ log(u), data = clotting, family = Gamma,
             control = parglm.control(nthreads = 1L))

# use two cores
f2 <- parglm(lot1 ~ log(u), data = clotting, family = Gamma,
             control = parglm.control(nthreads = 2L))
all.equal(coef(f1), coef(f2))

}
